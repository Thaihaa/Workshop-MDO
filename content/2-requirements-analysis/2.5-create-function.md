---
title: "2.5 T·∫°o AWS Lambda Functions"
date: 2023-07-14T11:02:05+06:00
weight: 25
chapter: false
---

## T·∫°o AWS Lambda Functions

Trong ph·∫ßn n√†y, ch√∫ng ta s·∫Ω t·∫°o c√°c Lambda functions c·∫ßn thi·∫øt cho h·ªá th·ªëng Microservices Deployment Orchestration c·ªßa ch√∫ng ta. C√°c Lambda functions n√†y s·∫Ω ƒë√≥ng vai tr√≤ quan tr·ªçng trong vi·ªác t·ª± ƒë·ªông h√≥a quy tr√¨nh tri·ªÉn khai.

### B∆∞·ªõc 1: Truy c·∫≠p d·ªãch v·ª• AWS Lambda

1. ƒêƒÉng nh·∫≠p v√†o AWS Management Console
2. T√¨m ki·∫øm v√† ch·ªçn d·ªãch v·ª• "Lambda"
3. Nh·∫•p v√†o n√∫t "Create function" ƒë·ªÉ b·∫Øt ƒë·∫ßu

![AWS Lambda Dashboard](/Workshop-MDO/images/2/lambda-db.jpg)

### B∆∞·ªõc 2: T·∫°o Deployment Initializer Function

1. Ch·ªçn "Author from scratch"
2. Nh·∫≠p th√¥ng tin c∆° b·∫£n:
   - Function name: `deployment-initializer`
   - Runtime: Python 3.11
   - Architecture: x86_64
   - Execution role: S·ª≠ d·ª•ng IAM role ƒë√£ t·∫°o ·ªü ph·∫ßn tr∆∞·ªõc ho·∫∑c t·∫°o role m·ªõi v·ªõi quy·ªÅn c·∫ßn thi·∫øt
3. Nh·∫•p v√†o "Create function"

![Create Function](/Workshop-MDO/images/2/create-function.jpg)

4. Sau khi function ƒë∆∞·ª£c t·∫°o, b·∫°n s·∫Ω ƒë∆∞·ª£c chuy·ªÉn ƒë·∫øn trang c·∫•u h√¨nh function

![Create Function](/Workshop-MDO/images/2/code-deployment-init.jpg)

5. Trong tab "Code", th√™m m√£ sau v√†o editor:

```python
import json
import boto3
import uuid
from datetime import datetime, timezone
import os

def lambda_handler(event, context):
    """
    Lambda function ƒë·ªÉ kh·ªüi t·∫°o deployment context
    """
    try:
        # T·∫°o deployment ID duy nh·∫•t
        deployment_id = str(uuid.uuid4())
        timestamp = datetime.now(timezone.utc).isoformat()
        
        # L·∫•y th√¥ng tin t·ª´ event
        environment = event.get('environment', 'staging')
        version = event.get('version', 'latest')
        region = event.get('region', os.environ.get('AWS_REGION', 'us-east-1'))
        
        # T·∫°o deployment context
        deployment_context = {
            "deployment_id": deployment_id,
            "timestamp": timestamp,
            "environment": environment,
            "version": version,
            "region": region,
            "status": "initialized",
            "services": {
                "auth-service": {"status": "pending", "deployment_time": None},
                "menu-service": {"status": "pending", "deployment_time": None},
                "order-service": {"status": "pending", "deployment_time": None},
                "payment-service": {"status": "pending", "deployment_time": None}
            },
            "rollback_required": False
        }
        
        # Log deployment kh·ªüi t·∫°o
        print(f"Deployment initialized: {deployment_id}")
        print(f"Environment: {environment}")
        print(f"Version: {version}")
        
        # Ghi log v√†o CloudWatch
        cloudwatch_logs = boto3.client('logs')
        log_group = '/aws/stepfunctions/restaurant-deployment'
        
        try:
            cloudwatch_logs.put_log_events(
                logGroupName=log_group,
                logStreamName=f'deployment-{deployment_id}',
                logEvents=[
                    {
                        'timestamp': int(datetime.now().timestamp() * 1000),
                        'message': json.dumps({
                            'event': 'deployment_initialized',
                            'deployment_id': deployment_id,
                            'environment': environment,
                            'version': version
                        })
                    }
                ]
            )
        except Exception as log_error:
            print(f"CloudWatch logging error: {str(log_error)}")
        
        return {
            'statusCode': 200,
            'deployment_context': deployment_context,
            'message': 'Deployment initialized successfully'
        }
        
    except Exception as e:
        error_message = f"Error initializing deployment: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'message': 'Failed to initialize deployment'
        } 
```

6. Nh·∫•p v√†o "Deploy" ƒë·ªÉ l∆∞u m√£

### B∆∞·ªõc 3: T·∫°o c√°c Lambda Functions kh√°c

L·∫∑p l·∫°i quy tr√¨nh tr√™n ƒë·ªÉ t·∫°o c√°c Lambda functions c√≤n l·∫°i:

1. **microservice-deployer**:
   - Runtime: Python 3.11
   - M√¥ t·∫£: Deploy t·ª´ng microservice ri√™ng l·∫ª

```python
import json
import boto3
import time
from datetime import datetime, timezone
import os

def lambda_handler(event, context):
    """
    Lambda function ƒë·ªÉ deploy microservice
    """
    try:
        # L·∫•y th√¥ng tin t·ª´ event
        service_name = event.get('service_name')
        deployment_context = event.get('deployment_context')
        
        if not service_name or not deployment_context:
            raise ValueError("Missing required parameters: service_name or deployment_context")
        
        deployment_id = deployment_context.get('deployment_id')
        environment = deployment_context.get('environment', 'staging')
        version = deployment_context.get('version', 'latest')
        
        print(f"Deploying {service_name} for deployment {deployment_id}")
        
        # Kh·ªüi t·∫°o AWS clients
        ecs_client = boto3.client('ecs')
        ecr_client = boto3.client('ecr')
        
        # C·∫•u h√¨nh service
        service_config = get_service_config(service_name, environment)
        
        # 1. Ki·ªÉm tra image trong ECR
        image_uri = check_and_get_image(ecr_client, service_config, version)
        
        # 2. C·∫≠p nh·∫≠t task definition
        task_definition_arn = update_task_definition(ecs_client, service_config, image_uri, deployment_id)
        
        # 3. Deploy service l√™n ECS
        service_arn = deploy_to_ecs(ecs_client, service_config, task_definition_arn, environment)
        
        # 4. Ch·ªù deployment ho√†n th√†nh
        deployment_status = wait_for_deployment(ecs_client, service_config['cluster_name'], service_config['service_name'])
        
        result = {
            'statusCode': 200,
            'service_name': service_name,
            'deployment_id': deployment_id,
            'task_definition_arn': task_definition_arn,
            'service_arn': service_arn,
            'deployment_status': deployment_status,
            'image_uri': image_uri,
            'deployment_time': datetime.now(timezone.utc).isoformat(),
            'message': f'{service_name} deployed successfully'
        }
        
        print(f"Successfully deployed {service_name}")
        return result
        
    except Exception as e:
        error_message = f"Error deploying {service_name}: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'service_name': service_name,
            'deployment_id': deployment_context.get('deployment_id') if deployment_context else None,
            'message': f'Failed to deploy {service_name}'
        }

def get_service_config(service_name, environment):
    """L·∫•y c·∫•u h√¨nh cho service"""
    base_config = {
        'auth-service': {
            'cluster_name': f'restaurant-{environment}',
            'service_name': f'auth-service-{environment}',
            'repository_name': 'restaurant/auth-service',
            'port': 8080,
            'cpu': 256,
            'memory': 512,
            'desired_count': 2
        },
        'menu-service': {
            'cluster_name': f'restaurant-{environment}',
            'service_name': f'menu-service-{environment}',
            'repository_name': 'restaurant/menu-service',
            'port': 8081,
            'cpu': 256,
            'memory': 512,
            'desired_count': 2
        },
        'order-service': {
            'cluster_name': f'restaurant-{environment}',
            'service_name': f'order-service-{environment}',
            'repository_name': 'restaurant/order-service',
            'port': 8082,
            'cpu': 512,
            'memory': 1024,
            'desired_count': 3
        },
        'payment-service': {
            'cluster_name': f'restaurant-{environment}',
            'service_name': f'payment-service-{environment}',
            'repository_name': 'restaurant/payment-service',
            'port': 8083,
            'cpu': 256,
            'memory': 512,
            'desired_count': 2
        }
    }
    
    if service_name not in base_config:
        raise ValueError(f"Unknown service: {service_name}")
    
    return base_config[service_name]

def check_and_get_image(ecr_client, service_config, version):
    """Ki·ªÉm tra v√† l·∫•y image URI t·ª´ ECR"""
    try:
        repository_name = service_config['repository_name']
        
        # L·∫•y th√¥ng tin image
        response = ecr_client.describe_images(
            repositoryName=repository_name,
            imageIds=[{'imageTag': version}]
        )
        
        if not response['imageDetails']:
            raise ValueError(f"Image {repository_name}:{version} not found in ECR")
        
        # L·∫•y registry ID t·ª´ response
        registry_id = response['imageDetails'][0]['registryId']
        region = ecr_client.meta.region_name
        
        image_uri = f"{registry_id}.dkr.ecr.{region}.amazonaws.com/{repository_name}:{version}"
        print(f"Found image: {image_uri}")
        
        return image_uri
        
    except ecr_client.exceptions.RepositoryNotFoundException:
        raise ValueError(f"ECR repository {repository_name} not found")
    except Exception as e:
        raise ValueError(f"Error checking ECR image: {str(e)}")

def update_task_definition(ecs_client, service_config, image_uri, deployment_id):
    """T·∫°o ho·∫∑c c·∫≠p nh·∫≠t task definition"""
    try:
        task_def_name = f"{service_config['service_name']}-{deployment_id}"
        
        task_definition = {
            'family': task_def_name,
            'networkMode': 'awsvpc',
            'requiresCompatibilities': ['FARGATE'],
            'cpu': str(service_config['cpu']),
            'memory': str(service_config['memory']),
            'executionRoleArn': os.environ.get('TASK_EXECUTION_ROLE_ARN'),
            'taskRoleArn': os.environ.get('TASK_ROLE_ARN'),
            'containerDefinitions': [
                {
                    'name': service_config['service_name'],
                    'image': image_uri,
                    'cpu': service_config['cpu'],
                    'memory': service_config['memory'],
                    'essential': True,
                    'portMappings': [
                        {
                            'containerPort': service_config['port'],
                            'protocol': 'tcp'
                        }
                    ],
                    'logConfiguration': {
                        'logDriver': 'awslogs',
                        'options': {
                            'awslogs-group': f'/ecs/{service_config["service_name"]}',
                            'awslogs-region': os.environ.get('AWS_REGION', 'us-east-1'),
                            'awslogs-stream-prefix': 'ecs'
                        }
                    },
                    'environment': [
                        {
                            'name': 'ENVIRONMENT',
                            'value': 'production'
                        },
                        {
                            'name': 'PORT',
                            'value': str(service_config['port'])
                        }
                    ]
                }
            ]
        }
        
        response = ecs_client.register_task_definition(**task_definition)
        task_definition_arn = response['taskDefinition']['taskDefinitionArn']
        
        print(f"Registered task definition: {task_definition_arn}")
        return task_definition_arn
        
    except Exception as e:
        raise ValueError(f"Error creating task definition: {str(e)}")

def deploy_to_ecs(ecs_client, service_config, task_definition_arn, environment):
    """Deploy service l√™n ECS cluster"""
    try:
        cluster_name = service_config['cluster_name']
        service_name = service_config['service_name']
        
        # Ki·ªÉm tra service ƒë√£ t·ªìn t·∫°i ch∆∞a
        try:
            services_response = ecs_client.describe_services(
                cluster=cluster_name,
                services=[service_name]
            )
            
            service_exists = len(services_response['services']) > 0 and \
                           services_response['services'][0]['status'] != 'INACTIVE'
            
        except Exception:
            service_exists = False
        
        if service_exists:
            # C·∫≠p nh·∫≠t service hi·ªán t·∫°i
            response = ecs_client.update_service(
                cluster=cluster_name,
                service=service_name,
                taskDefinition=task_definition_arn,
                desiredCount=service_config['desired_count']
            )
            print(f"Updated existing service: {service_name}")
        else:
            # T·∫°o service m·ªõi
            response = ecs_client.create_service(
                cluster=cluster_name,
                serviceName=service_name,
                taskDefinition=task_definition_arn,
                desiredCount=service_config['desired_count'],
                launchType='FARGATE',
                networkConfiguration={
                    'awsvpcConfiguration': {
                        'subnets': os.environ.get('SUBNET_IDS', '').split(','),
                        'securityGroups': [os.environ.get('SECURITY_GROUP_ID')],
                        'assignPublicIp': 'ENABLED'
                    }
                }
            )
            print(f"Created new service: {service_name}")
        
        return response['service']['serviceArn']
        
    except Exception as e:
        raise ValueError(f"Error deploying to ECS: {str(e)}")

def wait_for_deployment(ecs_client, cluster_name, service_name, max_wait_time=300):
    """Ch·ªù deployment ho√†n th√†nh"""
    start_time = time.time()
    
    while time.time() - start_time < max_wait_time:
        try:
            response = ecs_client.describe_services(
                cluster=cluster_name,
                services=[service_name]
            )
            
            service = response['services'][0]
            deployments = service['deployments']
            
            # T√¨m deployment PRIMARY
            primary_deployment = None
            for deployment in deployments:
                if deployment['status'] == 'PRIMARY':
                    primary_deployment = deployment
                    break
            
            if primary_deployment:
                running_count = primary_deployment['runningCount']
                desired_count = primary_deployment['desiredCount']
                
                print(f"Deployment status: {running_count}/{desired_count} tasks running")
                
                if running_count == desired_count:
                    return {
                        'status': 'STABLE',
                        'running_count': running_count,
                        'desired_count': desired_count
                    }
            
            time.sleep(10)
            
        except Exception as e:
            print(f"Error checking deployment status: {str(e)}")
            time.sleep(10)
    
    return {
        'status': 'TIMEOUT',
        'message': f'Deployment did not stabilize within {max_wait_time} seconds'
    } 
```

2. **health-checker**:
   - Runtime: Python 3.11
   - M√¥ t·∫£: Ki·ªÉm tra health c·ªßa t·ª´ng microservice sau khi deploy

```python
import json
import time
from datetime import datetime

def lambda_handler(event, context):
    """
    Mock health checker function - no external dependencies
    """
    try:
        service_name = event.get('service_name', 'unknown-service')
        deployment_result = event.get('deployment_result', {})
        
        print(f"Checking health for service: {service_name}")
        print(f"Deployment result: {deployment_result}")
        
        # Mock health check - simulate checking service health
        time.sleep(0.2)  # Simulate health check delay
        
        # Mock successful health check
        health_status = {
            "service_name": service_name,
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "health_checks": {
                "endpoint_accessible": True,
                "response_time_ms": 150,
                "cpu_usage": "25%",
                "memory_usage": "60%"
            }
        }
        
        print(f"Health check completed for {service_name}: {health_status}")
        
        return {
            'statusCode': 200,
            'health_status': health_status,
            'message': f'Mock health check passed for {service_name}'
        }
        
    except Exception as e:
        error_message = f"Error checking health for {service_name}: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'message': f'Health check failed for {service_name}'
        }
```

3. **final-health-checker**:
   - Runtime: Python 3.11
   - M√¥ t·∫£: Ki·ªÉm tra to√†n b·ªô h·ªá th·ªëng sau khi deploy ho√†n t·∫•t

```python

import json
import time
from datetime import datetime

def lambda_handler(event, context):
    """
    Mock final health checker - system-wide health check
    """
    try:
        deployment_context = event.get('deployment_context', {})
        all_services = event.get('all_services', [])
        
        deployment_id = deployment_context.get('deployment_id', 'unknown')
        
        print(f"Performing final health check for deployment: {deployment_id}")
        print(f"Services to check: {all_services}")
        
        # Mock system-wide health check
        time.sleep(0.3)  # Simulate comprehensive health check
        
        # Mock successful system health
        system_health = {
            "deployment_id": deployment_id,
            "overall_status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "services_status": {},
            "system_metrics": {
                "total_services": len(all_services),
                "healthy_services": len(all_services),
                "avg_response_time": "145ms",
                "system_load": "normal"
            }
        }
        
        # Mock individual service status
        for service in all_services:
            system_health["services_status"][service] = {
                "status": "healthy",
                "endpoint": f"http://{service}:8080/health",
                "response_time": "120ms",
                "last_check": datetime.now().isoformat()
            }
            
        print(f"Final health check completed: {system_health}")
        
        return {
            'statusCode': 200,
            'system_health': system_health,
            'message': f'System-wide health check passed for deployment {deployment_id}'
        }
        
    except Exception as e:
        error_message = f"Error in final health check: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'message': 'Final health check failed'
        }
```

4. **deployment-notifier**:
   - Runtime: Python 3.11
   - M√¥ t·∫£: G·ª≠i th√¥ng b√°o v·ªÅ tr·∫°ng th√°i deployment

```python
import json
import boto3
import os
from datetime import datetime, timezone

def lambda_handler(event, context):
    """
    Lambda function ƒë·ªÉ g·ª≠i th√¥ng b√°o v·ªÅ k·∫øt qu·∫£ deployment
    """
    try:
        # L·∫•y th√¥ng tin t·ª´ event
        status = event.get('status')  # SUCCESS ho·∫∑c FAILED
        deployment_context = event.get('deployment_context', {})
        error = event.get('error')
        services_deployed = event.get('services_deployed', [])
        
        deployment_id = deployment_context.get('deployment_id')
        environment = deployment_context.get('environment', 'unknown')
        version = deployment_context.get('version', 'unknown')
        
        print(f"Sending notification for deployment {deployment_id}: {status}")
        
        # Kh·ªüi t·∫°o AWS clients
        sns_client = boto3.client('sns')
        ses_client = boto3.client('ses')
        
        # T·∫°o n·ªôi dung th√¥ng b√°o
        notification_content = create_notification_content(
            status, deployment_id, environment, version, services_deployed, error
        )
        
        # G·ª≠i th√¥ng b√°o qua SNS
        sns_result = send_sns_notification(sns_client, notification_content)
        
        # G·ª≠i email th√¥ng b√°o chi ti·∫øt
        email_result = send_email_notification(ses_client, notification_content)
        
        # Ghi log v√†o CloudWatch
        log_result = log_to_cloudwatch(notification_content)
        
        # G·ª≠i th√¥ng b√°o t·ªõi Slack (n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh)
        slack_result = send_slack_notification(notification_content)
        
        result = {
            'statusCode': 200,
            'deployment_id': deployment_id,
            'notification_status': status,
            'notifications_sent': {
                'sns': sns_result,
                'email': email_result,
                'cloudwatch': log_result,
                'slack': slack_result
            },
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'message': f'Notifications sent for deployment {status}'
        }
        
        print(f"Notification completed for deployment {deployment_id}")
        return result
        
    except Exception as e:
        error_message = f"Error sending notifications: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'deployment_id': deployment_context.get('deployment_id') if deployment_context else None,
            'message': 'Failed to send notifications'
        }

def create_notification_content(status, deployment_id, environment, version, services_deployed, error):
    """T·∫°o n·ªôi dung th√¥ng b√°o"""
    timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
    
    if status == 'SUCCESS':
        subject = f"‚úÖ Deployment Th√†nh C√¥ng - {deployment_id}"
        
        message = f"""
üéâ DEPLOYMENT TH√ÄNH C√îNG

üìã Th√¥ng tin Deployment:
‚Ä¢ ID: {deployment_id}
‚Ä¢ Environment: {environment}
‚Ä¢ Version: {version}
‚Ä¢ Th·ªùi gian: {timestamp}

‚úÖ Services ƒë√£ deploy th√†nh c√¥ng:
{chr(10).join([f'‚Ä¢ {service}' for service in services_deployed])}

üîó Li√™n k·∫øt h·ªØu √≠ch:
‚Ä¢ AWS Console: https://console.aws.amazon.com/states/
‚Ä¢ CloudWatch Logs: https://console.aws.amazon.com/cloudwatch/
‚Ä¢ ECS Console: https://console.aws.amazon.com/ecs/

Deployment ƒë√£ ho√†n th√†nh th√†nh c√¥ng! T·∫•t c·∫£ microservices ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.
        """
        
        slack_color = "good"
        
    else:  # FAILED
        subject = f"‚ùå Deployment Th·∫•t B·∫°i - {deployment_id}"
        
        error_details = ""
        if error:
            error_details = f"\nüîç Chi ti·∫øt l·ªói:\n{json.dumps(error, indent=2, ensure_ascii=False)}"
        
        message = f"""
üö® DEPLOYMENT TH·∫§T B·∫†I

üìã Th√¥ng tin Deployment:
‚Ä¢ ID: {deployment_id}
‚Ä¢ Environment: {environment}
‚Ä¢ Version: {version}
‚Ä¢ Th·ªùi gian: {timestamp}

‚ùå Deployment kh√¥ng th√†nh c√¥ng{error_details}

üîß H√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán:
‚Ä¢ Ki·ªÉm tra CloudWatch Logs ƒë·ªÉ xem chi ti·∫øt l·ªói
‚Ä¢ Xem l·∫°i c·∫•u h√¨nh services
‚Ä¢ Ki·ªÉm tra health endpoints
‚Ä¢ Rollback n·∫øu c·∫ßn thi·∫øt

üîó Li√™n k·∫øt troubleshooting:
‚Ä¢ AWS Console: https://console.aws.amazon.com/states/
‚Ä¢ CloudWatch Logs: https://console.aws.amazon.com/cloudwatch/
‚Ä¢ ECS Console: https://console.aws.amazon.com/ecs/

Vui l√≤ng ki·ªÉm tra v√† kh·∫Øc ph·ª•c s·ª± c·ªë.
        """
        
        slack_color = "danger"
    
    return {
        'subject': subject,
        'message': message,
        'status': status,
        'deployment_id': deployment_id,
        'environment': environment,
        'version': version,
        'timestamp': timestamp,
        'slack_color': slack_color,
        'services_deployed': services_deployed,
        'error': error
    }

def send_sns_notification(sns_client, content):
    """G·ª≠i th√¥ng b√°o qua SNS"""
    try:
        topic_arn = os.environ.get('SNS_TOPIC_ARN')
        if not topic_arn:
            return {'sent': False, 'reason': 'SNS_TOPIC_ARN not configured'}
        
        response = sns_client.publish(
            TopicArn=topic_arn,
            Subject=content['subject'],
            Message=content['message']
        )
        
        print(f"SNS notification sent: {response['MessageId']}")
        return {
            'sent': True,
            'message_id': response['MessageId'],
            'topic_arn': topic_arn
        }
        
    except Exception as e:
        print(f"Error sending SNS notification: {str(e)}")
        return {'sent': False, 'error': str(e)}

def send_email_notification(ses_client, content):
    """G·ª≠i email th√¥ng b√°o chi ti·∫øt"""
    try:
        sender_email = os.environ.get('SENDER_EMAIL')
        recipient_emails = os.environ.get('RECIPIENT_EMAILS', '').split(',')
        
        if not sender_email or not recipient_emails[0]:
            return {'sent': False, 'reason': 'Email configuration not found'}
        
        # T·∫°o HTML email
        html_body = create_html_email(content)
        
        response = ses_client.send_email(
            Source=sender_email,
            Destination={
                'ToAddresses': [email.strip() for email in recipient_emails if email.strip()]
            },
            Message={
                'Subject': {
                    'Data': content['subject'],
                    'Charset': 'UTF-8'
                },
                'Body': {
                    'Text': {
                        'Data': content['message'],
                        'Charset': 'UTF-8'
                    },
                    'Html': {
                        'Data': html_body,
                        'Charset': 'UTF-8'
                    }
                }
            }
        )
        
        print(f"Email notification sent: {response['MessageId']}")
        return {
            'sent': True,
            'message_id': response['MessageId'],
            'recipients': recipient_emails
        }
        
    except Exception as e:
        print(f"Error sending email notification: {str(e)}")
        return {'sent': False, 'error': str(e)}

def create_html_email(content):
    """T·∫°o HTML email ƒë·∫πp"""
    status_color = "#28a745" if content['status'] == 'SUCCESS' else "#dc3545"
    status_icon = "‚úÖ" if content['status'] == 'SUCCESS' else "‚ùå"
    
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>{content['subject']}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }}
            .container {{ max-width: 600px; margin: 0 auto; background-color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
            .header {{ background-color: {status_color}; color: white; padding: 20px; border-radius: 8px 8px 0 0; text-align: center; }}
            .content {{ padding: 20px; }}
            .info-grid {{ display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0; }}
            .info-item {{ padding: 10px; background-color: #f8f9fa; border-radius: 4px; }}
            .services-list {{ background-color: #e8f5e8; padding: 15px; border-radius: 4px; margin: 15px 0; }}
            .error-details {{ background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 4px; margin: 15px 0; }}
            .footer {{ background-color: #f8f9fa; padding: 15px; border-radius: 0 0 8px 8px; text-align: center; font-size: 12px; color: #666; }}
            .btn {{ display: inline-block; padding: 10px 20px; background-color: {status_color}; color: white; text-decoration: none; border-radius: 4px; margin: 5px; }}
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>{status_icon} Deployment {content['status']}</h1>
                <p>ID: {content['deployment_id']}</p>
            </div>
            <div class="content">
                <div class="info-grid">
                    <div class="info-item">
                        <strong>Environment:</strong><br>
                        {content['environment']}
                    </div>
                    <div class="info-item">
                        <strong>Version:</strong><br>
                        {content['version']}
                    </div>
                    <div class="info-item">
                        <strong>Timestamp:</strong><br>
                        {content['timestamp']}
                    </div>
                    <div class="info-item">
                        <strong>Status:</strong><br>
                        {content['status']}
                    </div>
                </div>
    """
    
    if content['status'] == 'SUCCESS' and content['services_deployed']:
        html += f"""
                <div class="services-list">
                    <h3>‚úÖ Services deployed successfully:</h3>
                    <ul>
                        {''.join([f'<li>{service}</li>' for service in content['services_deployed']])}
                    </ul>
                </div>
        """
    
    if content['status'] == 'FAILED' and content['error']:
        error_str = json.dumps(content['error'], indent=2) if isinstance(content['error'], dict) else str(content['error'])
        html += f"""
                <div class="error-details">
                    <h3>‚ùå Error Details:</h3>
                    <pre>{error_str}</pre>
                </div>
        """
    
    html += f"""
                <div style="text-align: center; margin: 20px 0;">
                    <a href="https://console.aws.amazon.com/states/" class="btn">AWS Console</a>
                    <a href="https://console.aws.amazon.com/cloudwatch/" class="btn">CloudWatch</a>
                    <a href="https://console.aws.amazon.com/ecs/" class="btn">ECS Console</a>
                </div>
            </div>
            <div class="footer">
                <p>Automated notification from Restaurant Microservices Deployment System</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    return html

def log_to_cloudwatch(content):
    """Ghi log chi ti·∫øt v√†o CloudWatch"""
    try:
        cloudwatch_logs = boto3.client('logs')
        log_group = '/aws/stepfunctions/restaurant-deployment'
        log_stream = f'notifications-{content["deployment_id"]}'
        
        log_event = {
            'timestamp': int(datetime.now().timestamp() * 1000),
            'message': json.dumps({
                'event': 'deployment_notification_sent',
                'deployment_id': content['deployment_id'],
                'status': content['status'],
                'environment': content['environment'],
                'version': content['version'],
                'services_deployed': content['services_deployed'],
                'error': content['error'] if content['error'] else None,
                'notification_timestamp': content['timestamp']
            }, ensure_ascii=False, indent=2)
        }
        
        try:
            cloudwatch_logs.create_log_stream(
                logGroupName=log_group,
                logStreamName=log_stream
            )
        except cloudwatch_logs.exceptions.ResourceAlreadyExistsException:
            pass  # Log stream already exists
        
        cloudwatch_logs.put_log_events(
            logGroupName=log_group,
            logStreamName=log_stream,
            logEvents=[log_event]
        )
        
        print(f"CloudWatch log written to {log_group}/{log_stream}")
        return {'logged': True, 'log_group': log_group, 'log_stream': log_stream}
        
    except Exception as e:
        print(f"Error logging to CloudWatch: {str(e)}")
        return {'logged': False, 'error': str(e)}

def send_slack_notification(content):
    """G·ª≠i th√¥ng b√°o t·ªõi Slack"""
    try:
        webhook_url = os.environ.get('SLACK_WEBHOOK_URL')
        if not webhook_url:
            return {'sent': False, 'reason': 'SLACK_WEBHOOK_URL not configured'}
        
        import requests
        
        # T·∫°o Slack message format
        slack_message = {
            "text": f"Deployment {content['status']}: {content['deployment_id']}",
            "attachments": [
                {
                    "color": content['slack_color'],
                    "title": content['subject'],
                    "fields": [
                        {
                            "title": "Deployment ID",
                            "value": content['deployment_id'],
                            "short": True
                        },
                        {
                            "title": "Environment",
                            "value": content['environment'],
                            "short": True
                        },
                        {
                            "title": "Version",
                            "value": content['version'],
                            "short": True
                        },
                        {
                            "title": "Status",
                            "value": content['status'],
                            "short": True
                        }
                    ],
                    "footer": "Restaurant Deployment System",
                    "ts": int(datetime.now().timestamp())
                }
            ]
        }
        
        if content['status'] == 'SUCCESS' and content['services_deployed']:
            slack_message["attachments"][0]["fields"].append({
                "title": "Services Deployed",
                "value": "\n".join([f"‚Ä¢ {service}" for service in content['services_deployed']]),
                "short": False
            })
        
        if content['status'] == 'FAILED' and content['error']:
            error_str = str(content['error'])[:500]  # Limit error message length
            slack_message["attachments"][0]["fields"].append({
                "title": "Error",
                "value": f"```{error_str}```",
                "short": False
            })
        
        response = requests.post(webhook_url, json=slack_message, timeout=10)
        
        if response.status_code == 200:
            print("Slack notification sent successfully")
            return {'sent': True, 'webhook_url': webhook_url[:50] + '...'}
        else:
            return {'sent': False, 'error': f'HTTP {response.status_code}'}
            
    except Exception as e:
        print(f"Error sending Slack notification: {str(e)}")
        return {'sent': False, 'error': str(e)} 
```

5. **deployment-rollback**:
   - Runtime: Python 3.11
   - M√¥ t·∫£: Rollback deployment khi c√≥ l·ªói

```python
import json
import time
from datetime import datetime

def lambda_handler(event, context):
    """
    Mock deployment rollback function
    """
    try:
        deployment_context = event.get('deployment_context', {})
        error = event.get('error', {})
        
        deployment_id = deployment_context.get('deployment_id', 'unknown')
        
        print(f"Starting rollback for deployment: {deployment_id}")
        print(f"Error that triggered rollback: {error}")
        
        # Mock rollback process
        services = ['auth-service', 'menu-service', 'order-service', 'payment-service']
        
        for service in services:
            print(f"Rolling back {service}...")
            time.sleep(0.1)  # Simulate rollback work
            print(f"Rollback completed for {service}")
        
        result = {
            "rollback_status": "completed",
            "deployment_id": deployment_id,
            "timestamp": datetime.now().isoformat(),
            "services_rolled_back": services
        }
        
        print(f"Rollback completed successfully: {result}")
        
        return {
            'statusCode': 200,
            'rollback_result': result,
            'message': 'Mock rollback completed successfully'
        }
        
    except Exception as e:
        error_message = f"Error during rollback: {str(e)}"
        print(error_message)
        
        return {
            'statusCode': 500,
            'error': error_message,
            'message': 'Rollback failed'
        }
```


### B∆∞·ªõc 5: Ki·ªÉm th·ª≠ Lambda Function

1. Sau khi t·∫°o function, b·∫°n c√≥ th·ªÉ ki·ªÉm th·ª≠ b·∫±ng c√°ch nh·∫•p v√†o tab "Test"

![Lambda Functions](/Workshop-MDO/images/2/create-testevent.jpg)

2. Nh·∫•p v√†o "Create new event" n·∫øu b·∫°n ch∆∞a c√≥ test event
3. ƒê·∫∑t t√™n cho test event (v√≠ d·ª•: "TestDeploymentInit")
4. Nh·∫≠p JSON test event:

```json
{
  "services": ["auth-service", "user-service", "order-service"],
  "environment": "development",
  "requested_by": "admin"
}
```

5. Nh·∫•p v√†o "Save"
6. Nh·∫•p v√†o "Test" ƒë·ªÉ th·ª±c thi function v·ªõi test event



### B∆∞·ªõc 6: Xem logs v√† monitoring

1. Sau khi th·ª±c thi function, b·∫°n c√≥ th·ªÉ xem k·∫øt qu·∫£ v√† logs ngay trong giao di·ªán
2. ƒê·ªÉ xem CloudWatch Logs chi ti·∫øt, nh·∫•p v√†o tab "Monitor"
3. Ch·ªçn "View CloudWatch logs"

![CloudWatch Logs](/Workshop-MDO/images/2/view-cwl.jpg)

### B∆∞·ªõc 7: C·∫•u h√¨nh n√¢ng cao

ƒê·ªÉ c·∫•u h√¨nh n√¢ng cao cho c√°c Lambda functions:

1. Nh·∫•p v√†o tab "Configuration"
2. B·∫°n c√≥ th·ªÉ c·∫•u h√¨nh:
   - General configuration: Memory, timeout
   - Permissions: Execution role
   - Environment variables
   - VPC: K·∫øt n·ªëi function v·ªõi VPC
   - Asynchronous invocation
   - Concurrency

![Advanced Configuration](/Workshop-MDO/images/2/config-lambda.jpg)



### T·ªïng k·∫øt

B·∫°n ƒë√£ ho√†n th√†nh vi·ªác t·∫°o c√°c Lambda functions c·∫ßn thi·∫øt cho h·ªá th·ªëng Microservices Deployment Orchestration. C√°c functions n√†y s·∫Ω l√†m vi·ªác c√πng nhau ƒë·ªÉ t·ª± ƒë·ªông h√≥a quy tr√¨nh tri·ªÉn khai microservices. 